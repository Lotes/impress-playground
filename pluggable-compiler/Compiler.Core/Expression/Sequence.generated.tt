<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using Compiler.Core.Chars;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Compiler.Core.Expression
{
<#
int maxCount = 4;
string exprType = "IGrammarExpression"; 
Func<int, string> otype = num => "TOperand"+num;  
Func<int, IEnumerable<int>> range = num => Enumerable.Range(1, num); 
Func<int, string> otypeList = num => string.Join(", ", range(num).Select(n => "TOperand"+n));
Func<int, string> oformals = num => string.Join(", ", range(num).Select(n => exprType+"<TOperand"+n+"> operand"+n));

#>
	public interface IVisitor<TState>
    {
        TResult Visit_And<TResult, TOperand>(TState state, And<TResult, TOperand> and);
        TResult Visit_Call<TResult>(TState state, Call<TResult> call);
        TResult[] Visit_Repetition<TResult>(TState state, Repetition<TResult> repetition);
        TResult Visit_Choice<TResult, TOperand>(TState state, Choice<TResult, TOperand> choice);
        TResult Visit_CharacterClass<TResult>(TState state, CharacterClass<TResult> characterClass);
        TResult Visit_Named<TResult, TOperand>(TState state, Named<TResult, TOperand> named);
        TResult Visit_EOF<TResult>(TState state, EOF<TResult> eof);
        TResult Visit_Not<TResult, TOperand>(TState state, Not<TResult, TOperand> not);
<#
for(int count=1; count<maxCount; count++)
{
#>
        TResult Visit_Sequence<TResult, <#=otypeList(count)#>>(TState state, Sequence<TResult, <#=otypeList(count)#>> sequence);
<#
}
#>
    }

<#
for(int count=1; count<maxCount; count++)
{
#>
    public class Sequence<TResult, <#=otypeList(count)#>>: IGrammarExpression<TResult>
    {
        public Sequence(<#=oformals(count)#>)
        {
<#
	for(int index=1; index<=count; index++)
	{
#>
			this.Operand<#=index#> = operand<#=index#>;
<#
	}
#>
        }

<#
	for(int index=1; index<=count; index++)
	{
#>
		public <#=exprType+"<TOperand"+index+"> Operand"+index#> { get; }
<#
	}
#>

        public TResult Accept<S>(IVisitor<S> visitor, S state)
        {
            return visitor.Visit_Sequence(state, this);
        }
    }
<#
}
#>
}
